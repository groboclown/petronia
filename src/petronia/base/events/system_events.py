
"""
The events around system lifecycle.
"""

from typing import Sequence, Iterable, Dict, List, Union
from ..internal_.identity_types import (
    create_singleton_identity,
)
from ..internal_.bus_types import (
    EventBus, EventId, EventCallback,
    ListenerSetup,
)
from ..util.memory import readonly_dict

# Note: not "core".  This is not a plugin.
TARGET_ID_SYSTEM = create_singleton_identity('petronia.system')


# ---------------------------------------------------------------------------

EVENT_ID_SYSTEM_STARTED = EventId('petronia.system/started')


class SystemStartedEvent:
    """
    Event to indicate that all the basic systems at boot time have finished
    running, and the system is now safe for end user actions.
    """
    __slots__ = ()


def as_system_started_listener(
        callback: EventCallback[SystemStartedEvent]
) -> ListenerSetup[SystemStartedEvent]:
    return (EVENT_ID_SYSTEM_STARTED, callback,)


# ---------------------------------------------------------------------------

# Halted events are not bubbled up to the API level, because these must be
# handled only by the core system and by a shutdown extension.
EVENT_ID_SYSTEM_HALTED = EventId('petronia.system/halt')


class SystemHaltedEvent:
    """
    Stop the system immediately.
    """
    __slots__ = ()

    # TODO look at forcing a signed envelope on this event.


def as_system_halted_listener(
    callback: EventCallback[SystemHaltedEvent]
) -> ListenerSetup[SystemHaltedEvent]:
    return (EVENT_ID_SYSTEM_HALTED, callback,)


def send_system_halted(bus: EventBus) -> None:
    bus.trigger(EVENT_ID_SYSTEM_HALTED, TARGET_ID_SYSTEM, SystemHaltedEvent())


# ---------------------------------------------------------------------------

EVENT_ID_ERROR = EventId('petronia.system/error')


class ErrorEvent:
    """
    Petronia or a loaded extension encountered an error.  This can be generated by
    anything.

    This allows for localization of an error message, and to broadcast the issue to
    different extensions that may have custom ways to handle the message.
    """
    __slots__ = (
        '__source',
        '__message_code',
        '__arguments'
    )

    def __init__(
            self,
            source: str,
            message_code: str,
            arguments: Dict[str, Union[
                str, int, bool, float,
                Iterable[Union[str, int, bool, float]],
                Dict[str, Union[str, int, bool, float]]
            ]]
    ) -> None:
        self.__source = source
        self.__message_code = message_code

        # Perform a deep copy, to prevent possible post-send adjustments
        args: Dict[str, Union[
            str, int, bool, float,
            Sequence[Union[str, int, bool, float]],
            Dict[str, Union[str, int, bool, float]]
        ]] = {}
        for key, val in arguments.items():
            if isinstance(val, str):
                args[key] = val
            elif isinstance(val, dict):
                args[key] = readonly_dict(val)
            elif isinstance(val, Iterable):
                args[key] = tuple(val)
            else:
                args[key] = val
        self.__arguments = tuple(args)

    @property
    def source(self) -> str:
        """The source that detected the error, or, if possible, the underlying source of the error."""
        return self.__source

    @property
    def message_code(self) -> str:
        """The localizable message code that describes the specific error encountered."""
        return self.__message_code

    @property
    def arguments(self) -> Sequence[Union[
        str, int, bool, float,
        Sequence[Union[str, int, bool, float]],
        Dict[str, Union[str, int, bool, float]]
    ]]:
        """Informative details about the message; usually, this will be """
        return self.__arguments

    def __repr__(self) -> str:
        return 'ErrorEvent(source={source}, message_code={message_code}, arguments={arguments})'.format(
            source=repr(self.__source),
            message_code=repr(self.__message_code),
            arguments=repr(self.__arguments)
        )


def as_error_listener(
        callback: EventCallback[ErrorEvent]
) -> ListenerSetup[ErrorEvent]:
    return (EVENT_ID_ERROR, callback,)


def send_error_event(
        bus: EventBus,
        source: str,
        message_code: str,
        **arguments: Union[
            str, int, bool, float,
            Iterable[Union[str, int, bool, float]],
            Dict[str, Union[str, int, bool, float]]
        ]
) -> None:
    bus.trigger(EVENT_ID_ERROR, TARGET_ID_SYSTEM, ErrorEvent(
        source, message_code, arguments
    ))
