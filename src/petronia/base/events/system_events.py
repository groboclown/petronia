
"""
The events around system lifecycle.
"""

from typing import Iterable, Dict, Mapping, Union, Tuple
from typing import cast as t_cast
from ..internal_.identity_types import (
    create_singleton_identity,
)
from ..internal_.bus_types import (
    EventBus, EventId, EventCallback,
    ListenerSetup,
)
from ..util.memory import readonly_dict, T

# Note: not "core".  This is not a plugin.
TARGET_ID_SYSTEM = create_singleton_identity('petronia.system')


# ---------------------------------------------------------------------------

EVENT_ID_SYSTEM_STARTED = EventId('petronia.system/started')


class SystemStartedEvent:
    """
    Event to indicate that all the basic systems at boot time have finished
    running, and the system is now safe for end user actions.
    """
    __slots__ = ()


def as_system_started_listener(
        callback: EventCallback[SystemStartedEvent]
) -> ListenerSetup[SystemStartedEvent]:
    return (EVENT_ID_SYSTEM_STARTED, callback,)


# ---------------------------------------------------------------------------

# Halted events are not bubbled up to the API level, because these must be
# handled only by the core system and by a shutdown extension.
EVENT_ID_SYSTEM_HALTED = EventId('petronia.system/halt')


class SystemHaltedEvent:
    """
    Stop the system immediately.
    """
    __slots__ = ()

    # TODO look at forcing a signed envelope on this event.


def as_system_halted_listener(
    callback: EventCallback[SystemHaltedEvent]
) -> ListenerSetup[SystemHaltedEvent]:
    return (EVENT_ID_SYSTEM_HALTED, callback,)


def send_system_halted(bus: EventBus) -> None:
    bus.trigger(EVENT_ID_SYSTEM_HALTED, TARGET_ID_SYSTEM, SystemHaltedEvent())


# ---------------------------------------------------------------------------

EVENT_ID_ERROR = EventId('petronia.system/error')


MessageArgumentValueType = Union[
    str, int, bool, float, None, BaseException,
    Iterable[Union[str, int, bool, float, None]],
    Mapping[str, Union[str, int, bool, float, None]]
]


ERROR_CATEGORY_USER = 'user'
ERROR_CATEGORY_BUG = 'bug'
ERROR_CATEGORY_ENVIRONMENT = 'environment'
ERROR_CATEGORIES = (
    ERROR_CATEGORY_USER,
    ERROR_CATEGORY_BUG,
    ERROR_CATEGORY_ENVIRONMENT,
)


class ErrorReport:
    """
    Report on an error discovered in the system configuration or setup.
    This is used for problems that the end-user may have caused, and that the
    end user has the ability to fix.
    """

    __slots__ = ('__source', '__category', '__message', '__arguments')

    def __init__(
            self, source: str, category: str, message_code: str, arguments: Mapping[str, MessageArgumentValueType]
    ) -> None:
        assert category in ERROR_CATEGORIES
        self.__source = source
        self.__category = category
        self.__message = message_code
        # Perform a deep copy, to prevent possible post-send adjustments
        args: Dict[str, MessageArgumentValueType] = {}
        for key, val in arguments.items():
            if isinstance(val, str):
                args[key] = val
            elif isinstance(val, dict):
                args[key] = readonly_dict(t_cast(Mapping[str, Union[str, int, bool, float]], val))
            elif isinstance(val, Iterable):
                args[key] = tuple(val)
            else:
                args[key] = val
        self.__arguments = readonly_dict(args)

    @property
    def source(self) -> str:
        return self.__source

    @property
    def category(self) -> str:
        return self.__category

    @property
    def message_code(self) -> str:
        """The localizable message code that describes the specific error encountered."""
        return self.__message

    @property
    def arguments(self) -> Mapping[str, MessageArgumentValueType]:
        return self.__arguments

    def __repr__(self) -> str:
        return (
            'ErrorReport(source={source}, category={category}, message_code={message_code}, arguments={arguments})'
        ).format(
            source=repr(self.__source),
            category=repr(self.__category),
            message_code=repr(self.__message),
            arguments=repr(self.__arguments)
        )


ResultOrError = Union[T, ErrorReport]
ResultWithErrors = Tuple[T, Iterable[ErrorReport]]


class ErrorEvent:
    """
    Petronia or a loaded extension encountered an error.  This can be generated by
    anything.

    This allows for localization of an error message, and to broadcast the issue to
    different extensions that may have custom ways to handle the message.
    """
    __slots__ = (
        '__error',
    )

    def __init__(
            self,
            error: ErrorReport
    ) -> None:
        self.__error = error

    @property
    def error(self) -> ErrorReport:
        return self.__error

    def __repr__(self) -> str:
        return 'ErrorEvent(error={0})'.format(repr(self.__error))


def as_error_listener(
        callback: EventCallback[ErrorEvent]
) -> ListenerSetup[ErrorEvent]:
    return (EVENT_ID_ERROR, callback,)


def send_error_reports_event(
        bus: EventBus,
        *errors: ErrorReport
) -> None:
    for error in errors:
        bus.trigger(EVENT_ID_ERROR, TARGET_ID_SYSTEM, ErrorEvent(error))


def send_error_event(
        bus: EventBus,
        source: str,
        category: str,
        message_code: str,
        **arguments: MessageArgumentValueType
) -> None:
    send_error_reports_event(bus, ErrorReport(source, category, message_code, arguments))

