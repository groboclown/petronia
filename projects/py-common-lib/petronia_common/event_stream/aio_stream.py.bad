"""Run the shared prototypes with asyncio objects"""

from typing import List, Callable, Coroutine, Optional, Any
from abc import ABC
import asyncio
from .defs import RawEvent, RawBinaryReader, to_raw_event_binary
from .forwarder import EventForwarderTarget
from ..util import T_co


class AsyncEventForwarderTarget(EventForwarderTarget, ABC):
    """Interface for targets of events."""
    __slots__ = ('_timeout',)

    def __init__(self, timeout: Optional[float] = None) -> None:
        self._timeout = timeout

    def consume(self, event: RawEvent) -> bool:
        """Called if the `can_consume` method returns True.
        If this returns True, then the target will be de-registered."""
        return wait_in_loop(self.async_consume(event))

    async def async_consume(self, event: RawEvent) -> bool:
        """Async-aware version of the consume function."""
        raise NotImplementedError()  # pragma no cover


class AsyncBinaryReader:
    """Conforms to the BinaryReader protocol.  Expected to be
    run from within an async loop."""
    __slots__ = ('_stream', '_timeout',)

    def __init__(
            self,
            stream: 'StreamedBinaryReader',
            timeout: Optional[float] = None,
    ) -> None:
        self._stream = stream
        self._timeout = timeout

    def read(self, max_read_count: int = -1) -> bytes:
        """Read up to n bytes."""
        return wait_in_loop(self._stream.read_data(max_read_count))

    def as_raw_reader(self) -> RawBinaryReader:
        """Return this as a raw binary reader."""
        return self.read


class AsyncBinaryWriter:
    """Conforms to the BinaryWriter protocol."""
    __slots__ = ('_stream', '_timeout',)

    def __init__(
            self,
            async_writer: Callable[[bytes], Coroutine[Any, Any, None]],
            timeout: Optional[float] = None,
    ) -> None:
        self._stream = async_writer
        self._timeout = timeout

    def write(self, data: bytes) -> None:
        """Standard write method."""
        # Call result to ensure the appropriate exceptions are raised.
        wait_in_loop(self._stream(data))


def wait_in_loop(cor: Coroutine[Any, Any, T_co]) -> T_co:
    """Run the co-routine in the loop, and wait for it to finish.
    A running loop must be active"""
    loop = asyncio.get_running_loop()
    assert loop is not None
    task = loop.create_task(cor)
    # HOW DO WE DO THIS?!?  IS THIS EVEN POSSIBLE?!?
    # Don't want to do this in a thread, because then this loop will block forever on all
    # things until that task in that thread is done.
    return task.result()


async def async_stream_forwarder(  # pylint: disable=too-many-arguments,too-many-locals
        event_id: str,
        source_id: str,
        target_id: str,
        blob_size: int,
        reader: RawBinaryReader,
        targets: List[EventForwarderTarget],
        read_size: int,
) -> List[EventForwarderTarget]:
    """Forwards a binary event to 1 or more targets.
    It needs to read in a bit of data (up to the read_size),
    pass that on to each of the targets' readers, wait for those
    targets to finish consuming that data, then repeat until the
    data is fully processed."""
    streams: List[StreamedBinaryReader] = []
    processes: List[Coroutine[Any, Any, None]] = []
    to_remove: List[EventForwarderTarget] = []
    data_read_condition = asyncio.Condition()

    def can_read_next() -> bool:
        ret = True
        for stream in streams:
            ret = ret and stream.is_buffer_consumed()
        # print(f" -- Remaining stream data to read: {ret}")
        return ret

    def mk_handle_target(
            target: EventForwarderTarget,
            stream: StreamedBinaryReader,
    ) -> Coroutine[Any, Any, None]:
        async def handle_target() -> None:
            res = target.consume(to_raw_event_binary(
                event_id, source_id, target_id, blob_size,
                AsyncBinaryReader(stream).as_raw_reader(),
            ))
            if res:
                to_remove.append(target)
        return handle_target()

    for tgt in targets:
        stm = StreamedBinaryReader(data_read_condition)
        streams.append(stm)
        # Note: no await here.
        processes.append(mk_handle_target(tgt, stm))
    if not streams:
        # drain the reader
        while reader(read_size) != b'':
            pass
        return to_remove

    async def forward_stream() -> None:
        running = True
        while running:
            # Process some data...
            data = reader(read_size)
            for stream in streams:
                if not data:
                    # print(" !! sending EOF to stream")
                    stream.feed_eof()
                    running = False
                else:
                    # print(f" !! sending {len(data)} bytes of data to stream")
                    stream.feed_data(data)

            # Wait for the forwarding to be consumed...
            async with data_read_condition:
                # print("Waiting on data to be read...")
                if not can_read_next():
                    await data_read_condition.wait_for(can_read_next)

    processes.append(forward_stream())
    await asyncio.gather(*processes)
    return to_remove


class StreamedBinaryReader:
    """Pushes data to a stream, and notifies a condition when the buffer is read."""
    __slots__ = ('__condition', '__buffer', '__eof', '__waiter', '__loop')

    def __init__(self, condition: asyncio.Condition) -> None:
        self.__loop = asyncio.events.get_event_loop()
        self.__condition = condition
        self.__waiter: Optional[asyncio.Future[int]] = None  # pylint: disable=unsubscriptable-object
        self.__buffer = bytearray()
        self.__eof = False

    def is_buffer_consumed(self) -> bool:
        """Is there no more data to read in this buffer?"""
        # print(f" -- buffer size == {len(self.__buffer)}")
        return len(self.__buffer) <= 0

    def feed_data(self, buff: bytes) -> None:
        """Feed data to the stream."""
        # print(f" -- pumping {len(buff)} bytes of data")
        self.__buffer += buff
        # print(f" -- -- {len(self.__buffer)} bytes left to read (+ {len(buff)} bytes)")
        if self.__waiter:
            # print(f" -- -- notified waiting code.")
            self.__waiter.set_result(1)

    def feed_eof(self) -> None:
        """Feed an EOF to the stream."""
        # print(f" -- told EOF to reader")
        self.__eof = True
        if self.__waiter:
            # print(f" -- -- notified waiting code.")
            self.__waiter.set_result(1)

    async def __call__(self, max_read_count: int = -1) -> bytes:
        return await self.read_data(max_read_count)

    async def read_data(self, max_read_count: int) -> bytes:
        """Read data from the buffer, or wait for it to be loaded."""
        # print(f" -- reading {max_read_count} bytes from reader")

        # Should never happen, because this can cause problems.
        if max_read_count == 0:
            return b''

        # Loop through the retries for the read from buffer if its empty.
        while True:
            if max_read_count < 0:
                read_count = len(self.__buffer)
            else:
                read_count = min(max_read_count, len(self.__buffer))

            # print(f" -- -- computed read count: {read_count}")

            if read_count == 0:
                # No data left to process
                if self.__eof:
                    return b''
                # Now there's data we're waiting on, which hasn't reached us yet.
                assert self.__waiter is None
                self.__waiter = self.__loop.create_future()
                # print(" -- -- waiting on data to come in.")
                try:
                    await self.__waiter
                finally:
                    self.__waiter = None
                # Try again...
                # print(" -- -- trying read again")
                continue

            ret = self.__buffer[:read_count]
            del self.__buffer[:read_count]
            # print(f" -- -- {len(self.__buffer)} bytes left in reader (read {ret})")
            if not self.__buffer:
                # print(f" -- -- notifying pumper")
                async with self.__condition:
                    self.__condition.notify_all()
            return ret
