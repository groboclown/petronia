"""
The application loop for a winapi notification aware program.

This is the big, critical section of the code that needs to be highly optimized
and working really right, according to Windows rules, otherwise we end up with
a sluggish computer that acts weird and needs a reboot to clean up.
"""

# pylint is confused by optional fields that are callable.
# pylint:disable=not-callable


from typing import Dict, Tuple, Sequence, Optional, Callable
from typing import cast as t_cast
import threading
import atexit
from petronia_native.common import log
from .arch.native_funcs.windows_common import WindowsErrorMessage
from .arch import windows_constants
from .arch.native_funcs import (
    WINDOWS_FUNCTIONS,
    SHELL__CANCEL_CALLBACK_CHAIN,
    HWND, HHOOK, UINT, WPARAM, LPARAM,
    MessageCallback,
)
from .hook_messages import MessageEntry


_Hook = Callable[[], UINT]

THREAD_STATE__NOT_STARTED = 0
THREAD_STATE__THREAD_INITIALIZING = 1
THREAD_STATE__THREAD_STARTED = 2
THREAD_STATE__THREAD_LOOPING = 3
THREAD_STATE__THREAD_STOPPING = 4
THREAD_STATE__THREAD_STOPPED = 5


class WindowsMessageLoop:  # pylint:disable=too-many-instance-attributes
    """
    Connects to the important windows shell events,
    and directs those to callback functions.
    """

    __slots__ = (
        '_key_hook', '_shell_hook',
        '_hwnd', '__state',
        '_window_message_map', '_key_handler',
        '_shell_message_map',
        '_shell_handler',
        '_message_callback_handler',
        '_on_exit',
        '_thread',
    )

    def __init__(self) -> None:
        self._key_hook: Optional[HHOOK] = None
        self._shell_hook: Optional[HHOOK] = None
        self._hwnd: Optional[HWND] = None
        self.__state = THREAD_STATE__NOT_STARTED
        self._window_message_map: Dict[int, MessageCallback] = {}
        self._shell_message_map: Dict[int, MessageCallback] = {}
        self._key_handler: Optional[
            Callable[[int, int, bool, bool], Tuple[bool, Sequence[Tuple[int, bool]]]]
        ] = None
        self._on_exit: Callable[[], None] = default_on_exit
        self._thread: Optional[threading.Thread] = None

    @property
    def hwnd(self) -> Optional[HWND]:
        """Get the running message window's HWND."""
        return self._hwnd

    def set_key_handler(
            self, callback: Callable[
                [int, int, bool, bool], Tuple[bool, Sequence[Tuple[int, bool]]],
            ]
    ) -> None:
        """
        Sets the key handler.
        :param callback: arguments: (VK_CODE, scan_code, is_key_up, is_key_injected).
            Returns a tuple of
            (bool - true if cancel propagation of key, false if let it go through,
            list of (scancode, is_key_up) injected keys).
        :return: None
        """
        self._key_handler = callback

    def set_on_exit_callback(self, callback: Callable[[], None]) -> None:
        """Set the on-exit message loop callback."""
        self._on_exit = callback

    def add_message_handler(self, message: MessageEntry) -> None:
        """Add a message handler, generated by hook_messages"""
        if message[0]:
            # It's a shell message
            self._shell_message_map[message[1]] = message[2]
        else:
            self._window_message_map[message[1]] = message[2]

    def is_running(self) -> bool:
        """Is the thread running?"""
        return self.__state == THREAD_STATE__THREAD_LOOPING

    def is_alive(self) -> bool:
        """Is the thread running?"""
        return self._thread is not None and self._thread.is_alive()

    def start(self) -> None:
        """Start the event monitoring thread."""
        if self.__state != THREAD_STATE__NOT_STARTED:
            log.info("message pumper already started.")
            return

        log.info("message_pumper: Starting the Windows message pumper thread.")
        self._thread = threading.Thread(
            target=self._message_pumper,
            daemon=True,
        )
        self.__state = THREAD_STATE__THREAD_INITIALIZING
        self._thread.start()
        atexit.register(self.dispose)

    def dispose(self, timeout: float = -1.0) -> None:
        """Close all the connections."""
        log.info("message_pumper: Stopping the Windows message pumper thread.")
        if self._hwnd and WINDOWS_FUNCTIONS.window.close:  # pragma no cover
            WINDOWS_FUNCTIONS.window.close(self._hwnd)
        if (  # pragma no cover
                self.__state == THREAD_STATE__THREAD_LOOPING
                and WINDOWS_FUNCTIONS.window.send_message and self._hwnd
        ):
            log.info('dispose: Sending shutdown to window message consumer.')
            WINDOWS_FUNCTIONS.window.send_message(
                self._hwnd, UINT(windows_constants.WM_QUIT), t_cast(WPARAM, 0), t_cast(LPARAM, 0),
            )
        if self._key_hook and WINDOWS_FUNCTIONS.shell.unhook:  # pragma no cover
            WINDOWS_FUNCTIONS.shell.unhook(self._key_hook)
            self._key_hook = None
        if self._shell_hook and WINDOWS_FUNCTIONS.shell.unhook:  # pragma no cover
            WINDOWS_FUNCTIONS.shell.unhook(self._shell_hook)
            self._shell_hook = None
        self.__state = THREAD_STATE__THREAD_STOPPED
        self._hwnd = None

        # This seems to not be encountered, but is here to ensure the message loop
        # stops correctly.
        if self._thread and self._thread.is_alive():  # pragma no cover
            self._thread.join(timeout)  # pragma no cover

        self._thread = None

    def _message_pumper(self) -> None:
        # This runs in a background thread.
        # If this doesn't stop during shutdown, then an exception
        # is reported to the console.  This indicates that the quit
        # event message queue either didn't run soon enough, or it
        # was never triggered.

        log.trace('message_pump: In the message pumper')

        # This shouldn't happen, but just to be sure, because it being wrong could be
        # catastrophic to a system.
        if self.__state != THREAD_STATE__THREAD_INITIALIZING:  # pragma no cover
            raise ValueError('already running (or finished running)')  # pragma no cover
        self.__state = THREAD_STATE__THREAD_STARTED

        # These MUST be in the same thread!
        # So this registration can only happen right before the loop starts.

        if WINDOWS_FUNCTIONS.shell.keyboard_hook:  # pragma no cover
            hook = WINDOWS_FUNCTIONS.shell.keyboard_hook(self.message_key_handler)
            if isinstance(hook, WindowsErrorMessage):
                log.error("message_pump: Failed to register key handler: {hook}", hook=hook)
            else:
                self._key_hook = hook
                log.trace("message_pump: Registered keyboard hook {hook}", hook=hook)

        if (  # pragma no cover
                WINDOWS_FUNCTIONS.shell.create_global_message_handler
                and WINDOWS_FUNCTIONS.window.create_message_window
                and WINDOWS_FUNCTIONS.shell.register_window_hook
                and WINDOWS_FUNCTIONS.shell.pump_messages
        ):
            message_callback_handler = WINDOWS_FUNCTIONS.shell.create_global_message_handler(
                self._window_message_map,
            )
            hwnd = WINDOWS_FUNCTIONS.window.create_message_window(
                "PyWinShell Hooks", message_callback_handler,
            )
            if isinstance(hwnd, WindowsErrorMessage):  # pragma no cover
                log.error(  # pragma no cover
                    "message_pump: Error creating message window: {hwnd}; cannot continue.",
                    hwnd=hwnd,
                )
                return
            self._hwnd = hwnd
            if self._hwnd:  # pragma no cover
                log.trace("message_pump: Registering window hook {hwnd}", hwnd=self._hwnd)
                msg = WINDOWS_FUNCTIONS.shell.register_window_hook(
                    self._hwnd, self._window_message_map, self.message_shell_handler,
                )
                if isinstance(msg, WindowsErrorMessage):  # pragma no cover
                    log.error(  # pragma no cover
                        "message_pump: Failed to register window hook: {mesg}; cannot continue",
                        mesg=msg,
                    )
                else:
                    log.trace("message_pump: Register window hook message id: {mesg}", mesg=msg)

            log.debug("message_pump: Pumping messages...")

            # Thread sort-of-safety thing here...
            # It's hard to duplicate, so we skip it.  It's an added comfort thing that
            # could potentially still cause problems because of the lack of locks.
            if self.__state != THREAD_STATE__THREAD_STARTED:  # pragma no cover
                self.__state = THREAD_STATE__THREAD_STOPPING  # pragma no cover
                self.dispose()  # pragma no cover
                return  # pragma no cover

            self.__state = THREAD_STATE__THREAD_LOOPING
            WINDOWS_FUNCTIONS.shell.pump_messages(self._on_exit)
        else:  # pragma no cover
            log.error(  # pragma no cover
                "message_pump: Basic platform functions not defined; cannot continue"
            )

        log.info('message_pump: Stopping the Windows message pumper')
        self.__state = THREAD_STATE__THREAD_STOPPING

    def message_key_handler(
            self,
            vk_code: int, scan_code: int, is_key_up: bool, is_injected: bool,
    ) -> Optional[str]:
        """Key handler, called inside the message pumper."""
        # print(f"[key] {vk_to_names(vk_code)} {vk_code} {'up' if is_key_up else 'dn'}")
        if self._key_handler:
            res = self._key_handler(vk_code, scan_code, is_key_up, is_injected)
            if WINDOWS_FUNCTIONS.shell.inject_scancode and res[1]:
                for inject_scancode, inject_is_up in res[1]:
                    # print(" - injecting {0} {1}".format(inject_scancode, inject_is_up))
                    WINDOWS_FUNCTIONS.shell.inject_scancode(inject_scancode, inject_is_up)
                    # Injection may cause a problem, but that's ignored.
            if res[0]:
                # print(" - cancelling callback chain for key")
                return SHELL__CANCEL_CALLBACK_CHAIN
            # else:
            #     print(" - passing on key")
        return None

    def message_shell_handler(
            self,
            source_hwnd: HWND, message: int, wparam: WPARAM, lparam: LPARAM,
    ) -> bool:
        """Shell message handler, called from within the message pumper."""
        # Shell window messages use the WPARAM to specify the kind of shell event.
        # See https://docs.microsoft.com/en-us/windows/win32/api/winuser/
        # nf-winuser-registershellhookwindow
        wparam_msg = t_cast(int, wparam)
        if wparam_msg in self._shell_message_map:
            log.trace(
                'shell: {source}: {message} ({wparam}: {wparam_msg})',
                source=source_hwnd,
                message=message,
                wparam=wparam,
                wparam_msg=self._shell_message_map.get(wparam_msg),
            )
            return self._shell_message_map[wparam_msg](source_hwnd, message, wparam, lparam)
        log.trace(
            'shell: 0x{wparam_msg:08x} not handled '
            '({message:08x} / {wparam:08x} / {lparam:08x})',
            wparam_msg=wparam_msg,
            message=message,
            wparam=wparam,
            lparam=lparam,
        )
        return True


def default_on_exit() -> None:
    """The default on-exit handler. Does nothing"""
