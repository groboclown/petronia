"""
Launch extensions from a child process.
"""
from typing import Sequence, Tuple, Mapping, Dict, List, Optional
import os

from petronia_common.event_stream import (
    BinaryReader, BinaryWriter, write_object_event_to_stream,
    raw_event_id, is_raw_event_object, as_raw_event_object_data,
)
from petronia_common.event_stream.reader import MarkedStreamReader, parse_raw_event
from petronia_common.extension.config.extension_schema import ExtensionRuntime
from petronia_common.util import StdRet, RET_OK_NONE, error_message, i18n
from .run_native import get_native_exec_args
from .run_python import get_python_exec_args
from .cmd_events import extension_commands
from ..abc import AbcLauncherCategory, RuntimeContext
from ...configuration import LauncherConfig
from ...configuration.launcher_parameters import is_boot_launcher
from ...process_mgmt import ManagedProcess, run_launcher
from ...constants import TRANSLATION_CATALOG

# Instead of the reimport, just make the assignment.
_ = i18n


def create_cmd_launcher(options: LauncherConfig) -> AbcLauncherCategory:
    """Create a command launcher category"""
    return CmdLauncherCategory(options)


class CmdLauncherCategory(AbcLauncherCategory):
    """Launches processes."""
    __slots__ = ('_processes', '_exec_res', '_context')

    def __init__(self, options: LauncherConfig) -> None:
        AbcLauncherCategory.__init__(self, options)
        self._processes: Dict[str, LaunchedProcess] = {}
        self._exec_res = get_runtime_settings(options)
        self._context: Optional[RuntimeContext] = None

    def is_valid(self) -> StdRet[None]:
        if self._exec_res.has_error:
            self._exec_res.forward()
        return RET_OK_NONE

    def initialize(self, context: RuntimeContext) -> StdRet[None]:
        self._context = context
        return RET_OK_NONE

    def start_launcher(
            self, launcher_id: str, permissions: Mapping[str, List[str]],
    ) -> StdRet[None]:
        if not self._context:
            return StdRet.pass_errmsg(
                TRANSLATION_CATALOG,
                _('Launcher not initialized'),
            )
        if self._exec_res.has_error:
            return self._exec_res.forward()
        launcher_runtime = ExtensionRuntime(launcher_id, permissions)
        command, env = self._exec_res.result
        # Boot launchers register themselves immediately, because extensions are not loaded.
        # The extension-loadable launchers must first perform the extension loading event
        # dance, which means that it cannot be added to a forwarding channel until the
        # extension has completed loading.
        res_process = run_launcher(
            launcher_id,
            launcher_runtime,
            command, env,
            self._context.get_platform(),
        )
        if res_process.has_error:
            return res_process.forward()
        process = LaunchedProcess(launcher_runtime, res_process.result)
        self._processes[launcher_id] = process

        if is_boot_launcher(self.options):
            res = self._context.register_channel(
                launcher_id,
                process.as_channel_res,
            )
            if res.has_error:
                # Close off our process
                res_stop = self.stop_launcher(launcher_id)
                if res_stop.has_error:
                    res = StdRet.pass_error(res.valid_error, res_stop.valid_error)
            return res
        return RET_OK_NONE

    def start_extension(  # pylint:disable=too-many-arguments
            self, launcher_id: str, handler_id: str, extension_name: str,
            extension_version: Tuple[int, int, int], location: str,
    ) -> StdRet[None]:
        if not self._context:
            return StdRet.pass_errmsg(
                TRANSLATION_CATALOG,
                _('Launcher not initialized'),
            )

        if is_boot_launcher(self.options):
            return StdRet.pass_errmsg(
                TRANSLATION_CATALOG,
                _('cannot load an extension in a boot launcher ({launcher_id}).'),
                launcher_id=launcher_id,
            )
        # This request is only generated by the extension loader.

        # This must be done carefully.  Non-boot launchers have not yet been added
        # to a channel, so that the extension loading event dance can happen.
        launcher = self._get_launcher(launcher_id)
        if launcher.has_error:
            return launcher.forward()

        # TODO move the extension location into the temporary
        #   directory for the process.

        write_object_event_to_stream(
            launcher.result.process,
            extension_commands.InternalLoadExtensionRequestEvent.FULL_EVENT_NAME,
            'source', 'target',
            extension_commands.InternalLoadExtensionRequestEvent(
                name=extension_name,
                version=list(extension_version),
            ).export_data(),
        )
        reader = MarkedStreamReader(launcher.result.process.reader)
        raw_event, error, eof = parse_raw_event(reader)

        # ensure it loaded right
        if not error and eof:
            error = error_message(
                TRANSLATION_CATALOG,
                _(
                    'Launcher {launcher_id} stopped communication before '
                    'extension {extension_name} could load'
                ),
                launcher_id=launcher_id,
                extension_name=extension_name,
            )
        if not error and raw_event is not None:
            event_id = raw_event_id(raw_event)
            if (
                not is_raw_event_object(raw_event)
                or event_id not in (
                    extension_commands.InternalLoadExtensionFailedEvent.FULL_EVENT_NAME,
                    extension_commands.InternalLoadExtensionSuccessEvent.FULL_EVENT_NAME,
                )
            ):
                # Invalid event type
                error = error_message(
                    TRANSLATION_CATALOG,
                    _('invalid event ID {event_id} received from launcher {launcher_id}'),
                    event_id=event_id,
                    launcher_id=launcher_id,
                )
            elif event_id == extension_commands.InternalLoadExtensionFailedEvent.FULL_EVENT_NAME:
                # failed to load extension event.
                error_event = extension_commands.InternalLoadExtensionFailedEvent.parse_data(
                    as_raw_event_object_data(raw_event),
                )
                if error_event.has_error:
                    error = error_event.valid_error
                else:
                    error = error_message(
                        TRANSLATION_CATALOG,
                        i18n(error_event.result.error.message),
                        **{
                            arg.name: arg.value
                            for arg in error_event.result.error.arguments
                        },
                    )
        if error:
            # This is a fall-through state for any error case that may have happened above.
            res_stop = launcher.result.stop()
            del self._processes[launcher_id]
            if res_stop.has_error:
                return StdRet.pass_error(error, res_stop.valid_error)
            return StdRet.pass_error(error)

        # Extension loading happened just fine, so allow the launcher to start receiving
        # events from the router.

        return self._context.register_channel(launcher_id, launcher.result.as_channel_res)

    def get_active_launcher_ids(self) -> Sequence[str]:
        return tuple(self._processes.keys())

    def stop_launcher(self, launcher_id: str) -> StdRet[None]:
        launcher = self._get_launcher(launcher_id)
        if launcher.has_error:
            return launcher.forward()
        res = launcher.result.stop()
        if res.ok:
            del self._processes[launcher_id]
        return res

    def _get_launcher(self, launcher_id: str) -> StdRet['LaunchedProcess']:
        launcher = self._processes.get(launcher_id)
        if not launcher:
            return StdRet.pass_errmsg(
                TRANSLATION_CATALOG,
                _('No registered launcher {launcher_id}'),
                launcher_id=launcher_id,
            )
        return StdRet.pass_ok(launcher)

    def stop(self) -> StdRet[None]:
        ret = []
        # TODO do this in parallel.
        for launcher in self._processes.values():
            res = launcher.stop()
            if res.has_error:
                ret.append(res.valid_error)
        if ret:
            return StdRet.pass_error(*ret)
        return RET_OK_NONE


class LaunchedProcess:
    """Information about a launched process"""
    __slots__ = ('extension_runtime', 'process',)

    def __init__(
            self,
            extension_runtime: ExtensionRuntime,
            process: ManagedProcess,
    ) -> None:
        self.extension_runtime = extension_runtime
        self.process = process

    def as_channel_res(self) -> StdRet[Tuple[BinaryReader, BinaryWriter]]:
        """Convert this value into a channel registration result."""
        return StdRet.pass_ok((self.process.reader, self.process))

    def stop(self) -> StdRet[None]:
        """Try to nicely, then forcefully, stop the process."""
        self.process.close_writer()
        if not self.process.wait_for_stop(5.0):
            self.process.stop()
            if not self.process.wait_for_stop(60.0):
                return StdRet.pass_errmsg(
                    TRANSLATION_CATALOG,
                    _('Could not stop launcher {launcher_id} within {timeout} seconds.'),
                    launcher_id=self.extension_runtime.launcher,
                    timeout=65,
                )
        return RET_OK_NONE


def get_runtime_settings(
        options: LauncherConfig,
) -> StdRet[Tuple[str, Dict[str, str]]]:
    """Get the executable settings for the options: the
    executable arguments and the environment variables
    """
    executable = options.get_option('exe')
    if executable.has_error:
        return executable.forward()
    if executable.result == 'py':
        return get_python_runtime_settings(options)
    return get_native_exec_args(executable.result)


def get_python_runtime_settings(
        options: LauncherConfig,
) -> StdRet[Tuple[str, Dict[str, str]]]:
    """Get the runtime settings for a python executable."""
    res_module = options.get_option('module')
    if res_module.has_error:
        return res_module.forward()
    res_module_path = options.get_option('path')
    if res_module_path.ok:
        module_path = res_module_path.result.split(os.path.pathsep)
    else:
        module_path = []
    res_py_exec = get_python_exec_args(
        res_module.result, module_path, False,
    )
    return res_py_exec
