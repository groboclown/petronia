"""
Launch extensions from a child process.
"""
from typing import Sequence, Tuple, Mapping, Dict, List, Optional
import os

from petronia_common.event_stream import raw_event_id
from petronia_common.event_stream.reader import MarkedStreamReader, parse_raw_event
from petronia_common.extension.config.extension_schema import ExtensionRuntime
from petronia_common.util import StdRet, RET_OK_NONE
from petronia_common.util import i18n as _
from .run_native import get_native_exec_args
from .run_python import get_python_exec_args
from ..abc import AbcLauncherCategory, RuntimeContext
from ..util import (
    no_such_launcher_id, launcher_category_not_initialized, launcher_already_registered,
    started_extension_from_boot_launcher,
    LaunchedInstance, request_extension_load, parse_extension_load_event,
)
from ...configuration import LauncherConfig
from ...process_mgmt import ManagedProcess, run_launcher
from ...constants import TRANSLATION_CATALOG


def create_cmd_launcher(options: LauncherConfig) -> AbcLauncherCategory:
    """Create a command launcher category"""
    return CmdLauncherCategory(options)


class CmdLauncherCategory(AbcLauncherCategory):
    """Launches processes."""
    __slots__ = ('_processes', '_exec_res', '_context')

    def __init__(self, options: LauncherConfig) -> None:
        AbcLauncherCategory.__init__(self, options)
        self._processes: Dict[str, LaunchedProcess] = {}
        self._exec_res = get_runtime_settings(options)
        self._context: Optional[RuntimeContext] = None

    def is_valid(self) -> StdRet[None]:
        if self._exec_res.has_error:
            self._exec_res.forward()
        return RET_OK_NONE

    def initialize(self, context: RuntimeContext) -> StdRet[None]:
        self._context = context
        return RET_OK_NONE

    def start_launcher(
            self, launcher_id: str, permissions: Mapping[str, List[str]],
    ) -> StdRet[None]:
        if not self._context:
            return launcher_category_not_initialized()
        if self._exec_res.has_error:
            return self._exec_res.forward()
        if launcher_id in self._processes:
            launcher_already_registered(launcher_id)
        launcher_runtime = ExtensionRuntime(launcher_id, permissions)
        command, env = self._exec_res.result
        # Boot launchers register themselves immediately, because extensions are not loaded.
        # The extension-loadable launchers must first perform the extension loading event
        # dance, which means that it cannot be added to a forwarding channel until the
        # extension has completed loading.
        res_process = run_launcher(
            launcher_id,
            launcher_runtime,
            command, env,
            self._context.get_platform(),
        )
        if res_process.has_error:
            return res_process.forward()
        process = LaunchedProcess(launcher_id, self.config, launcher_runtime, res_process.result)
        res = process.post_launch_processing(self._context)
        if res.ok:
            self._processes[launcher_id] = process
        return res

    def start_extension(  # pylint:disable=too-many-arguments
            self, launcher_id: str, handler_id: str, extension_name: str,
            extension_version: Tuple[int, int, int], location: str,
    ) -> StdRet[None]:
        if not self._context:
            return launcher_category_not_initialized()

        # This request is only generated by the extension loader.

        # This must be done carefully.  Non-boot launchers have not yet been added
        # to a channel, so that the extension loading event dance can happen.
        launcher_res = self._get_launcher(launcher_id)
        if launcher_res.has_error:
            return launcher_res.forward()
        if launcher_res.result.is_boot_launcher:
            started_extension_from_boot_launcher(launcher_id)

        # TODO move the extension location into the temporary
        #   directory for the process.

        res = request_extension_load(
            launcher_res.result, handler_id, extension_name, extension_version,
        )
        if res.has_error:
            return res

        # For later...
        assert res.ok

        # One launcher per extension.  So this expects the next event from
        # the launcher to be the extension start or fail.
        reader = MarkedStreamReader(launcher_res.result.reader)
        raw_event, error, eof = parse_raw_event(reader)
        if error:
            res = StdRet.pass_error(error)
        elif eof:
            res = StdRet.pass_errmsg(
                TRANSLATION_CATALOG,
                _(
                    'Launcher {launcher_id} stopped communication before '
                    'extension {extension_name} could load'
                ),
                launcher_id=launcher_id,
                extension_name=extension_name,
            )
        elif raw_event is not None:
            event_res = parse_extension_load_event(raw_event)
            if event_res.ok and event_res.value is None:
                # Invalid event type
                res = StdRet.pass_errmsg(
                    TRANSLATION_CATALOG,
                    _('invalid event ID {event_id} received from launcher {launcher_id}'),
                    event_id=raw_event_id(raw_event),
                    launcher_id=launcher_id,
                )
            elif event_res.ok:
                res = RET_OK_NONE
            else:
                res = event_res.forward()

        if res.ok:
            res = self._context.register_channel(launcher_id, launcher_res.result.as_channel_res)

        if res.has_error:
            # because one launcher per extension...
            del self._processes[launcher_id]
            res_stop = launcher_res.result.stop()
            if res_stop.has_error:
                return StdRet.pass_error(res.valid_error, res_stop.valid_error)
            return res

        return res

    def get_active_launcher_ids(self) -> Sequence[str]:
        return tuple(self._processes.keys())

    def stop_launcher(self, launcher_id: str) -> StdRet[None]:
        launcher = self._get_launcher(launcher_id)
        if launcher.has_error:
            return launcher.forward()
        res = launcher.result.stop()
        if res.ok:
            del self._processes[launcher_id]
        return res

    def _get_launcher(self, launcher_id: str) -> StdRet['LaunchedProcess']:
        launcher = self._processes.get(launcher_id)
        if not launcher:
            return no_such_launcher_id(launcher_id)
        return StdRet.pass_ok(launcher)

    def stop(self) -> StdRet[None]:
        ret = []
        # TODO do this in parallel.
        for launcher in self._processes.values():
            res = launcher.stop()
            if res.has_error:
                ret.append(res.valid_error)
        if ret:
            return StdRet.pass_error(*ret)
        return RET_OK_NONE


class LaunchedProcess(LaunchedInstance):
    """Information about a launched process"""
    __slots__ = ('extension_runtime', 'process',)

    def __init__(
            self,
            launcher_id: str,
            options: LauncherConfig,
            extension_runtime: ExtensionRuntime,
            process: ManagedProcess,
    ) -> None:
        LaunchedInstance.__init__(
            self, launcher_id, options, process.reader, process, self._local_stop,
        )
        self.extension_runtime = extension_runtime
        self.process = process

    def _local_stop(self, timeout: float) -> StdRet[None]:
        """Try to nicely, then forcefully, stop the process."""
        self.process.close_writer()
        if not self.process.wait_for_stop(timeout):
            self.process.stop()
            if not self.process.wait_for_stop(timeout * 4.0):
                return StdRet.pass_errmsg(
                    TRANSLATION_CATALOG,
                    _('Could not stop launcher {launcher_id} within {timeout} seconds.'),
                    launcher_id=self.extension_runtime.launcher,
                    timeout=timeout * 5.0,
                )
        return RET_OK_NONE


def get_runtime_settings(
        options: LauncherConfig,
) -> StdRet[Tuple[Sequence[str], Dict[str, str]]]:
    """Get the executable settings for the options: the
    executable arguments and the environment variables
    """
    executable = options.get_option('exe')
    if executable.has_error:
        return executable.forward()
    if executable.result == 'py':
        return get_python_runtime_settings(options)
    return get_native_exec_args(executable.result)


def get_python_runtime_settings(
        options: LauncherConfig,
) -> StdRet[Tuple[Sequence[str], Dict[str, str]]]:
    """Get the runtime settings for a python executable."""
    res_module = options.get_option('module')
    if res_module.has_error:
        return res_module.forward()
    res_module_path = options.get_option('path')
    if res_module_path.ok:
        module_path = res_module_path.result.split(os.path.pathsep)
    else:
        module_path = []
    res_py_exec = get_python_exec_args(
        res_module.result, module_path, False,
    )
    return res_py_exec
