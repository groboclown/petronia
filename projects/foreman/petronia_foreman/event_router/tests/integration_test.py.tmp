
import asyncio
import unittest
import io
from ..channel import EventChannel
from ..handler import EventHandler
from ..router import EventRouter
from petronia_common.event_stream import (
    RawEvent,
    write_binary_event_to_stream,
    write_object_event_to_stream,
    read_event_stream,
)
from petronia_common.util import StdRet


class RouterIntegrationTest(unittest.TestCase):
    """Tests how this will all work together.  Let's see how feasible it is to write."""
    def test_intra_channel(self) -> None:
        handler_1 = EventHandler('h1', {
            'e1': False,
            'e2': True,
        }, ['e1', 'e3'])
        handler_2 = EventHandler('h2', {
            'e2': False,
        }, ['e1', 'e2'])
        monitor = CallbackMonitor()
        inp = asyncio.events.set_child_watcher()
        inp.at_eof()
        outp = io.BytesIO()

        async def run_setup() -> EventRouter:
            router = EventRouter(asyncio.Semaphore())
            res = await router.add_channel(
                'ch1',
                monitor.output_callback,
                monitor.pass_through_cb,
                monitor.invalid_source_cb,
            )
            self.assertIsNone(res.error)
            res = await router.add_handler(handler_1, 'ch1')
            self.assertIsNone(res.error)
            res = await router.add_handler(handler_2, 'ch1')
            self.assertIsNone(res.error)
            return router

        setup_task = run_setup()

        async def run_read() -> None:
            read_event_stream(
                inp,

            )

        asyncio.gather(setup_task, )


class CallbackMonitor:
    def output_callback(self, event: RawEvent) -> StdRet[None]:
        pass

    def pass_through_cb(self, event: RawEvent) -> bool:
        pass

    def invalid_source_cb(self, event: RawEvent) -> bool:
        pass

